<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta name="author" content="OpenTable"><link rel="icon" href="/favicon.png"><title>OpenTable Tech UK Blog</title><meta name="description"><link rel="alternate" type="application/rss+xml" title="OpenTable Tech UK Blog" href="/atom.xml"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/main.css"><script src="//fonts.otstatic.com/zys4lfz.js"></script><link rel="stylesheet" href="/css/highlight.css">
</head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#main-navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">OpenTable Tech UK Blog</a></div><div id="main-navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/about/">About</a></li><li><a href="/archives/">Archive</a></li><li><a href="/blog/authors/">Authors</a></li></ul></div><div class="avatar-container"><div class="avatar-img-border"><a href="/"><img src="/opentable.png" class="avatar-img"></a></div></div></div></nav><header class="header-section"><div class="intro-header no-img"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><h1>testing-node-apps-with-docker-compose (and some Soul)</h1><p class="post-meta">Posted by <a href="/blog/authors/fmaffei.html">fmaffei</a>, 18 November 2016 · <a href="/blog/categories/Docker/" class="tag post-meta">Docker</a> · <a href="/blog/categories/Node-js/" class="tag post-meta">Node-js</a> · <a href="/blog/categories/TDD/" class="tag post-meta">TDD</a> · <a href="/blog/categories/Compose/" class="tag post-meta">Compose</a></p></div></div></div></div></div></header><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role="main" class="blog-post"><h2 id="Contents-of-this-post"><a href="#Contents-of-this-post" class="headerlink" title="Contents of this post"></a>Contents of this post</h2><ul>
<li><a href="#purpose">Purpose</a>: the reason for this blog post.</li>
<li><a href="#scenario">Scenario</a>: what this example of using docker-compose can be useful for.</li>
<li><a href="#prerequisites">Prerequisites</a>: basic setup to be able to run the code contained in this post.</li>
<li><a href="#example">Code example</a>: an actual step-by-step guide on how you can setup your test environment to run with docker-compose.</li>
<li><a href="#improvements">Improvements</a>: a couple of ideas on how to expand this technique.</li>
</ul>
<h2 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a><a name="purpose"></a>Purpose</h2><p>As I am sure the audience of this post knows to some extent, <a href="https://www.docker.com/what-docker" target="_blank" rel="noopener">Docker</a> is a technology that has grown to become popular over the last few years, allowing developers to deploy pieces of software by packaging them into standardized containers, in a number of various ecosystems (Apache Mesos, Amazon Web Services and many more).</p>
<p>So we can use Docker for our deployment needs, awesome. But let’s pay attention to a key word I used above. Docker grants <em>isolation</em>. And what do we like to perform on our application in isolation? Yeah, you guessed right &ndash; testing!</p>
<p>Specifically, with this post, I aim to dig deeper into how to use <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">docker-compose</a> (a specific Docker-based tool that enables creation of multi-container Docker applications) to build and run a Node.js application connected to MongoDB, to test their interaction and the interaction of the app with the external world, all inside containers running on your machine. All isolated and testable thanks to the usage of containers that we can spin up, hit with tests, and clean up with little effort. </p>
<p>Interested? Let’s go!</p>
<h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a><a name="scenario"></a>Scenario</h2><p>In this scenario we will use Docker and one of its functionalities, docker-compose, to build a container and spin up our app.  Then we build another container with a copy of the database where we can freely create and manipulate data, and finally we perform all the integration testing we want against those self-contained entities, which we can clean up after the tests ran. Total isolation and, very importantly, no need to pollute our development or pre-production environment with superfluous test data.</p>
<p>Let’s imagine an app that we can build and test, for example a directory of soul music artists.</p>
<p>Then let’s scope what our app needs to do, and how to test it. Our purpose is to:</p>
<ul>
<li>Test that when we hit the <code>/</code> path we get a 200 response and a basic home page.</li>
<li>Test that we can post a payload against the <code>/artist</code> path, to create one entry in our database (let’s say the great Marvin Gaye).</li>
<li>Test that when we hit the <code>/artist/marvingaye</code> we get the artist page with its name</li>
</ul>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a><a name="prerequisites"></a>Prerequisites</h2><p>Before diving into the prototype we should make sure everything is setup correctly. Requirements:</p>
<ul>
<li>Node.js v4 and npm</li>
<li><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker v1.12</a> (assuming you are on OSX you can use Docker For Mac)</li>
<li><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">Docker Compose</a></li>
<li>The <a href="https://mochajs.org/#installation" target="_blank" rel="noopener">Mocha</a> testing framework</li>
</ul>
<h2 id="Code-example"><a href="#Code-example" class="headerlink" title="Code example"></a><a name="example"></a>Code example</h2><h3 id="Step-1-Scaffolding"><a href="#Step-1-Scaffolding" class="headerlink" title="Step 1: Scaffolding"></a>Step 1: Scaffolding</h3><p>Let’s build as little as we can without testing.</p>
<p>This first step is not the most crucial one for this blog post’s sake, so I will not delve into it too much. <a href="https://github.com/federicomaffei/soul-compose" target="_blank" rel="noopener">I have pushed everything into a Github repo</a>, so you will be able to see how the code should look like at each step.</p>
<p>We will use the <a href="http://hapijs.com/" target="_blank" rel="noopener">hapi.js</a> framework to create a basic server application and <a href="https://github.com/federicomaffei/soul-compose/blob/78400f40606c032fb01542d35e579dc851d82fb3/package.json" target="_blank" rel="noopener">here is the package.json</a> file of the Soul Compose app with all the dependencies you need to get started. Copy it in your home folder and run:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>Now let’s go ahead and create an <a href="https://github.com/federicomaffei/soul-compose/blob/78400f40606c032fb01542d35e579dc851d82fb3/index.js" target="_blank" rel="noopener">index.js</a> file which will host our server. This is the only thing I will not test, it just comes out of the box with Hapi.js.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Hapi = <span class="built_in">require</span>(<span class="string">'hapi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> Hapi.Server();</span><br><span class="line"></span><br><span class="line">server.connection(&#123;</span><br><span class="line">    port: <span class="number">3000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.start(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Server running at:'</span>, server.info.uri);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="Code-example-at-this-point"><a href="#Code-example-at-this-point" class="headerlink" title="Code example at this point."></a><a href="https://github.com/federicomaffei/soul-compose/tree/78400f40606c032fb01542d35e579dc851d82fb3" target="_blank" rel="noopener">Code example at this point.</a></h5><h3 id="Step-2-Test-the-path"><a href="#Step-2-Test-the-path" class="headerlink" title="Step 2: Test the / path"></a>Step 2: Test the / path</h3><p>Now we can add something interesting: a failing test where we try to hit the / path of the app and expect to get a status code 200 and some text. Let’s write it using Mocha syntax:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(<span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    request.get(<span class="string">`http://localhost:3000`</span>, (error, res, b) =&gt; &#123;</span><br><span class="line">        response = res;</span><br><span class="line">        body = b;</span><br><span class="line">        done();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">'returns a 200 and a message'</span>, () =&gt; &#123;</span><br><span class="line">    expect(response.statusCode).to.equal(<span class="number">200</span>);</span><br><span class="line">    expect(body).to.equal(<span class="string">'Funky soul singers'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>It obviously fails, because we have no handler for that route and the app is not running. Let’s add a little code to fix this:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.route(&#123;</span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    handler: <span class="function">(<span class="params">req, reply</span>) =&gt;</span> &#123;</span><br><span class="line">        reply(<span class="string">'Funky soul singers'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>And then start the app, before running tests again:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>Tests green!</p>
<h5 id="Code-example-at-this-point-1"><a href="#Code-example-at-this-point-1" class="headerlink" title="Code example at this point."></a><a href="https://github.com/federicomaffei/soul-compose/tree/70f945e8e79e7fb62f4dda37cecbd2611f6630ea" target="_blank" rel="noopener">Code example at this point.</a></h5><h3 id="Step-3-Dockerise-the-app"><a href="#Step-3-Dockerise-the-app" class="headerlink" title="Step 3: Dockerise the app"></a>Step 3: Dockerise the app</h3><p>There is already something we could improve here. We are hitting the ‘real’ app with our request, but this is not what we call isolation, right?</p>
<p>Now is a good time to pull Docker in. We can use docker-compose to build a container with our app that runs on port 3001, nice and separated from our development one. Let’s do it.</p>
<p>All we need to do is create a Dockerfile in the root folder:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM node:4-onbuild</span><br><span class="line">EXPOSE 3000</span><br><span class="line">ENTRYPOINT [&quot;/usr/local/bin/node&quot;, &quot;index.js&quot;]</span><br></pre></td></tr></table></figure>
<p>Let’s take a look at what this set of instructions mean. We are building a container with our app, taking the base image from the Node.js official image (the environment where the app will run), exposing the port that the app will use for serving requests, and running the server at last. This, by the way, is a pretty standard way of using a Node.js within Docker.</p>
<p>Now, to spin up the app and hit it with tests, let’s use docker-compose. This will come in useful later, when we will add another container (the database) linked with our app. For now it will run a single container. To do it, all we need to do is create a <a href="https://github.com/federicomaffei/soul-compose/blob/faca99d02178407f3ffa9bfd932bcb8932dfd2e0/docker-compose.yml" target="_blank" rel="noopener">docker-compose.yml</a> file in our root folder:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  soul-compose:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3001:3000"</span></span><br></pre></td></tr></table></figure>
<p>This is a standard way of adding a service to a docker-compose configuration file. We are declaring that the context of the container is the top folder (where the Dockerfile that will be used to build it lives), and mapping port 3000 of the container to port 3001 of our local environment. This will allow the container to run in parallel with the app running locally, without the risk of having port allocation issues.<br>Now, let’s build and run our one-container composition:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>The interesting detail here is the -d option: it basically allows the container to run detached from the command line (in background mode, if you wish). This means we can stay on the same terminal and just run the tests again.</p>
<p>And (making sure we changed our tests to make requests to port 3001) our single test should pass! Now on to bigger things.</p>
<h5 id="Code-example-at-this-point-2"><a href="#Code-example-at-this-point-2" class="headerlink" title="Code example at this point."></a><a href="https://github.com/federicomaffei/soul-compose/tree/faca99d02178407f3ffa9bfd932bcb8932dfd2e0" target="_blank" rel="noopener">Code example at this point.</a></h5><h3 id="Step-4-New-artist-throw-Mongo-into-the-mix"><a href="#Step-4-New-artist-throw-Mongo-into-the-mix" class="headerlink" title="Step 4: New artist (throw Mongo into the mix)!"></a>Step 4: New artist (throw Mongo into the mix)!</h3><p>So the first acceptance test passes. Now, let’s test a route that allows us to create an entry for a new artist, and test that if we hit an endpoint called <code>/artist</code> with a payload, we get a 200 code from the route. It won’t actually create it for now, but it will give us a path to do the actual creation later.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(<span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">        method: <span class="string">'POST'</span>,</span><br><span class="line">        uri: <span class="string">'http://localhost:3001/artist'</span>,</span><br><span class="line">        body: &#123; <span class="attr">name</span>: <span class="string">'Marvin Gaye'</span>, <span class="attr">id</span>: <span class="string">'marvingaye'</span> &#125;,</span><br><span class="line">        json: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    request(options, (error, res, b) =&gt; &#123;</span><br><span class="line">        response = res;</span><br><span class="line">        body = b;</span><br><span class="line">        done();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">'returns a 200 and a message'</span>, () =&gt; &#123;</span><br><span class="line">    expect(response.statusCode).to.equal(<span class="number">200</span>);</span><br><span class="line">    expect(body).to.equal(<span class="string">'Created a soul singer named Marvin Gaye'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Let’s go ahead and make it green, but without actually creating the artist.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.route(&#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    path: <span class="string">'/artist'</span>,</span><br><span class="line">    handler: <span class="function">(<span class="params">req, reply</span>) =&gt;</span> &#123;</span><br><span class="line">        reply(<span class="string">`Created a soul singer named <span class="subst">$&#123;req.payload.name&#125;</span>`</span>).code(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>In the next test we can dive into the thick of it: let’s say that we now want to get a nice, shiny page for the singer we just created, reading it from a data persistence system (we’ll use MongoDB):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(<span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    request.get(<span class="string">`http://localhost:3001/artist/marvingaye`</span>, (error, res, b) =&gt; &#123;</span><br><span class="line">        response = res;</span><br><span class="line">        body = b;</span><br><span class="line">        done();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">'returns a 200 and an artist page'</span>, () =&gt; &#123;</span><br><span class="line">    expect(response.statusCode).to.equal(<span class="number">200</span>);</span><br><span class="line">    expect(body).to.equal(<span class="string">'Marvin Gaye'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This acceptance test will give me the chance to show how we can hook up another Docker image (<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener">MongoDB</a>) to docker-compose, and run the test doing a write (the POST) and a read (a GET) from that DB instance.</p>
<p>I am going to add some boilerplate code that serves the purpose of having a connection to the db and perform reads and writes (<a href="https://github.com/federicomaffei/soul-compose/blob/bfe5d89c907cc2dc55acfbd4a763fdc56f9763b8/index.js" target="_blank" rel="noopener">find it here</a>). The important detail is the fact that now it is actually used in the endpoints we are testing. We are ready to re-run our tests.</p>
<h5 id="Code-example-at-this-point-3"><a href="#Code-example-at-this-point-3" class="headerlink" title="Code example at this point."></a><a href="https://github.com/federicomaffei/soul-compose/tree/bfe5d89c907cc2dc55acfbd4a763fdc56f9763b8" target="_blank" rel="noopener">Code example at this point.</a></h5><p>The tests will fail, the reason being that our app is unable to connect to the database in its Docker environment at this point. So let’s take advantage of the features of docker-compose, and add a fully-featured MongoDB instance ready to be used, adding it to our <a href="https://github.com/federicomaffei/soul-compose/blob/2962d28e33366a92801f0ef2c18ef3dc7dd9f9db/docker-compose.yml" target="_blank" rel="noopener">docker-compose.yml</a> file.</p>
<p>Let’s go through the code. First and foremost, we added an entry for the MongoDB image to be built and run:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mongodb:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">mongo:3.0.11</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"27018:27017"</span></span><br><span class="line"><span class="attr">  command:</span> <span class="bullet">--smallfiles</span></span><br></pre></td></tr></table></figure>
<p>To make sure that the app and MongoDB load up in the right order (mongo, then app) we can also specify a <em>depends_on</em> property, meaning the app will wait for Mongo to start, and then will be able to access it through the hostname <em>mongodb</em>.</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">soul-compose:</span></span><br><span class="line"><span class="attr">  build:</span></span><br><span class="line"><span class="attr">    context:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"3001:3000"</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">NODE_ENV=test</span></span><br><span class="line"><span class="attr">  depends_on:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mongodb</span></span><br></pre></td></tr></table></figure>
<p>This means we will also have to change the code in the app to take that into account. One way to do it is by exporting an environment variable in the application container using docker-compose (as you can see above), and set the MongoDB hostname depending on it <a href="https://github.com/federicomaffei/soul-compose/blob/2962d28e33366a92801f0ef2c18ef3dc7dd9f9db/index.js" target="_blank" rel="noopener">in our index.js file</a>. A small but important change.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoHost = process.env.NODE_ENV === <span class="string">'test'</span> ? <span class="string">'mongodb'</span> : <span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure>
<p>And this covers what we had in scope. You should be able to re-run the tests to watch them going green. Pat yourself on the back!</p>
<h5 id="Code-example-at-this-point-4"><a href="#Code-example-at-this-point-4" class="headerlink" title="Code example at this point."></a><a href="https://github.com/federicomaffei/soul-compose/tree/2962d28e33366a92801f0ef2c18ef3dc7dd9f9db" target="_blank" rel="noopener">Code example at this point.</a></h5><h2 id="Improvements"><a href="#Improvements" class="headerlink" title="Improvements"></a><a name="improvements"></a>Improvements</h2><p>Let’s wrap up with some improvements we could make to the current state of the application.</p>
<p>An useful exercise would be creating a <a href="https://github.com/federicomaffei/soul-compose/blob/fcb8b653988672f16670c0c65db599b0c8fb2580/scripts/run-tests.sh" target="_blank" rel="noopener">script file</a> to perform all the commands to build the docker-compose images, run the tests, and perform a <a href="https://github.com/federicomaffei/soul-compose/blob/master/scripts/run-tests.sh#L10" target="_blank" rel="noopener">cleanup of the test images and containers</a>.</p>
<p>And then slightly modify the <em>npm test</em> command in package.json to run the script:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"test": "./scripts/run-tests.sh"</span><br></pre></td></tr></table></figure>
<h5 id="Code-example-at-this-point-5"><a href="#Code-example-at-this-point-5" class="headerlink" title="Code example at this point."></a><a href="https://github.com/federicomaffei/soul-compose/tree/fcb8b653988672f16670c0c65db599b0c8fb2580" target="_blank" rel="noopener">Code example at this point.</a></h5><p>Other ideas for improvement:</p>
<ul>
<li><p>Modify the Node.js Dockerfile to use suggested <a href="https://github.com/nodejs/docker-node/blob/master/docs/BestPractices.md" target="_blank" rel="noopener">best practices</a>.</p>
</li>
<li><p>Pull in more dependencies your app might have into the docker-compose.yml, like <a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener">Redis</a>.</p>
</li>
<li><p>Change from using the <em>onbuild</em> Node.js image to a more customized Dockerfile that does not run npm install at every build but <a href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/" target="_blank" rel="noopener">instead caches modules</a> if the <em>package.json</em> file has not changed, dramatically reducing execution time of the tests.</p>
</li>
</ul>
<p>Thanks for reading!</p>
<hr>
<p>Thanks to <a href="https://twitter.com/stefanoric" target="_blank" rel="noopener">Stefano Ricciardi</a> for the proof-reading and feedback.</p>
</article><ul class="pager blog-pager"><li class="previous"><a href="/blog/2017/02/15/the-goal-driven-organisation/" data-toggle="tooltip" data-placement="top" title="The goal driven organisation">← Previous Post</a></li><li class="next"><a href="/blog/2016/11/09/falcor-postman/" data-toggle="tooltip" data-placement="top" title="falcor-postman">Next Post →</a></li></ul></div></div></div><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href="https://github.com/opentable" title="GitHub"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-github"></i></span></a></li><li><a href="https://twitter.com/opentabletechuk" title="Twitter"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-twitter"></i></span></a></li><li><a href="https://www.linkedin.com/company/12181" title="LinkedIn"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-linkedin"></i></span></a></li><li><a href="http://stackoverflow.com/jobs/companies/opentable" title="StackOverflow"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-stack-overflow"></i></span></a></li></ul><p class="copyright text-muted">© OpenTable • 2019 • <a href="mailto:undefined"></a>
</p><p class="theme-by text-muted">Theme by
<a href="https://github.com/twoyao/beautiful-hexo">beautiful-hexo</a></p></div></div></div></footer><script src="/js/jquery-1.11.2.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="/js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
    a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-2621903-16', 'auto');
ga('send', 'pageview');</script></body></html>