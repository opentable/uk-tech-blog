<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta name="author" content="OpenTable"><link rel="icon" href="/favicon.png"><title>OpenTable Tech UK Blog</title><meta name="description"><link rel="alternate" type="application/rss+xml" title="OpenTable Tech UK Blog" href="/atom.xml"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/main.css"><script src="//fonts.otstatic.com/zys4lfz.js"></script><link rel="stylesheet" href="/css/highlight.css">
</head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#main-navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">OpenTable Tech UK Blog</a></div><div id="main-navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/about/">About</a></li><li><a href="/archives/">Archive</a></li><li><a href="/blog/authors/">Authors</a></li></ul></div><div class="avatar-container"><div class="avatar-img-border"><a href="/"><img src="/opentable.png" class="avatar-img"></a></div></div></div></nav><header class="header-section"><div class="intro-header no-img"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><h1>Internationalisation in a RESTful world</h1><p class="post-meta">Posted by <a href="/blog/authors/aroyle.html">aroyle</a>, 2 April 2014 · <a href="/blog/categories/API/" class="tag post-meta">API</a> · <a href="/blog/categories/REST/" class="tag post-meta">REST</a> · <a href="/blog/categories/i18n/" class="tag post-meta">i18n</a> · <a href="/blog/categories/Internationalisation/" class="tag post-meta">Internationalisation</a> · <a href="/blog/categories/http/" class="tag post-meta">http</a></p></div></div></div></div></div></header><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role="main" class="blog-post"><p>I18n is often a painful afterthought when serving content from a http-api. It can be taken for granted and tacked on using nasty query string values. But thankfully HTTP provides us with a solid gold opportunity. If you can look past the mire of content negotiation you can see the nuggets that lie inside.</p>
<p>The accept-language header is used by most browsers and allows websites to serve content in a language that the user can (hopefully) understand. When we expose content from an api (in most of our use cases, at least), this content eventually ends up in front of a human (in some shape or form). Having our service-service communication serve localised resources can be invaluable because it frees the clients from having to think about i18n of the resources being served from our api.</p>
<p>It is a simple part of the HTTP specification and is widely used and supported.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GET /product/123</div><div class="line">Accept-Language: en-US</div></pre></td></tr></table></figure>
<p>The accept-language header is specifically designed to allow the server to provide a representation of the resource which approximates something the client can understand.</p>
<p>The really useful bit comes from the quality value. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GET /product/123</div><div class="line">Accept-Language: en-US,en;q=0.8</div></pre></td></tr></table></figure>
<p>This header asks the service to provide en-US, and if it’s unavailable then fall back to <strong>any</strong> english representation. The quality value (<code>q=0.8</code>) is a decimal value between 0 and 1 which indicates order of preference when specifying multiple languages. The server should pick the <strong>first</strong> available match. If there are multiple matches with the same quality value, then the server can pick any. If the client wants to specify some fierce preferences then they can crank out something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GET /product/123</div><div class="line">Accept-Language: fr-CA,fr-FR;q=0.8,fr;q=0.6,en-US;q=0.4,en;q=0.2,*;q=0.1</div></pre></td></tr></table></figure>
<p>If you decipher this it’s pretty simple, you can see the quality headers giving the order in which the languages are preferred. What it does is give the client fantastic flexibility. For service-service communication you might have a use-case which will <em>never</em> serve a representation that doesn’t match the request, or you might need to <em>always</em> provide some representation (i.e. for cases where some content is always better than none).</p>
<p>The accept-language header gives you that flexibility. In my opinon, if your http-api’s are serving content that <em>can</em> be internationalised, the server should always support this type of behaviour because it can shift the control from the server to the client. It allows the server’s behaviour to be incredibly explicit and the clients get all that lovely flexibility.</p>
<p><strong>What happens when there is no matching representation?</strong></p>
<p>Well, the specification is (intentionally) vague. In other words, it is up to the server to decide. I myself always prefer to be explicit. Thankfully the HTTP specification provides for just such an eventuality.</p>
<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="_blank" rel="external">HTTP 406 Not Acceptable</a> <em>“The resource identified by the request is only capable of generating response entities which have content characteristics not acceptable according to the accept headers sent in the request.”</em></p>
<p>The 406 response <em>should</em> contain a list of characteristics which the resource does support. In this case, a list of available languages. The specification does allow the server to automatically select a representation to return, however in my opinion, the server should be explicit, rather than implicit.</p>
<p>If the client has a use case where it <em>always</em> requires some sort of response (i.e. where any content is better than no content), then the client can append a wildcard to the end of the accept-language header, which will instruct the server to fall back to <em>any</em> language, in the event that there are none matching.</p>
<p><strong>Parsing the Accept-Language header</strong></p>
<p>I wrote a little npm module to help us in <a href="https://github.com/andyroyle/accept-language-parser" target="_blank" rel="external">parsing the accept-language header</a>. Once you get past the (somewhat hairy) regex, it’s a simple little bit of code. (Disclaimer, I’m not a regex god, so there are a couple of little bugs in it).</p>
<p>Parsing an accept-language string such as <code>en-US,en;q=0.8</code> gives an object looking like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;</div><div class="line">    code: &quot;en&quot;,</div><div class="line">    region: &quot;GB&quot;,</div><div class="line">    quality: 1.0</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    code: &quot;en&quot;,</div><div class="line">    region: undefined,</div><div class="line">    quality: 0.8</div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>Output is always sorted in quality order from highest -&gt; lowest. as per the http spec, omitting the quality value implies 1.0.</p>
<p>We can pass this around our application and use it to select the representation which best matches the client’s request.</p>
<p><strong>Using it</strong></p>
<p>We use <a href="http://hapijs.com" target="_blank" rel="external">hapi.js</a> for some of our api’s (and I’m very much in love), we use this module in a pre-requisite handler in our route:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var alparser = require(&apos;accept-language-parser&apos;);</div><div class="line">server.route(&#123;</div><div class="line">  method: &quot;GET&quot;,</div><div class="line">  path: &quot;/v5/restaurants/&#123;id&#125;&quot;,</div><div class="line">  config: &#123;</div><div class="line">    pre: [</div><div class="line">      &#123;</div><div class="line">        method: function(req, next)&#123;</div><div class="line">          next(alparser.parse(req.raw.req.headers[&quot;accept-language&quot;] || &quot;&quot;));</div><div class="line">        &#125;,</div><div class="line">        assign: &quot;language&quot;,</div><div class="line">        mode: &quot;parallel&quot;</div><div class="line">      &#125;</div><div class="line">    ],</div><div class="line">    handler: function(req, reply)&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>For those of you that don’t know, the prerequisites run before the handler, and assign their values to the request object. You can now get hold of the parsed language object here:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">req.pre.language</div></pre></td></tr></table></figure>
<p><strong>Content-Negotiation is hard</strong></p>
<p>Yes, it is. But suck it up. In my opinion the benefits outweigh the costs. Besides, the Accept-Language header is part of the HTTP specification and is well understood. If you have doubts, start small, and always try to be <em>explicit</em> rather than implicit.</p>
<p><strong>Gotchas</strong></p>
<p>Caching (both client-side and intermediate) can be picky. By default, most caches won’t respect the header content (i.e. the resource is cached by url only). You can get around this by using vary-headers:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /product/123</div><div class="line">Accept-Language: en-GB,en;q=0.8</div><div class="line">Vary: Accept-Language</div></pre></td></tr></table></figure>
<p>This instructs the cache that the response will vary with the value of Accept-Language, so when this changes it should be cached as a separate resource. Vary headers <strong>should</strong> be applied by the client to the request, however the server can apply them to the response if necessary.</p>
</article><ul class="pager blog-pager"><li class="previous"><a href="/blog/2014/04/04/forgefriday-our-commitment-to-the-puppet-forge/" data-toggle="tooltip" data-placement="top" title="ForgeFriday - our commitment to the Puppet Forge">← Previous Post</a></li><li class="next"><a href="/blog/2014/03/20/when-to-performance-test-in-production/" data-toggle="tooltip" data-placement="top" title="When to performance test in production">Next Post →</a></li></ul></div></div></div><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href="https://github.com/opentable" title="GitHub"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-github"></i></span></a></li><li><a href="https://twitter.com/opentabletechuk" title="Twitter"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-twitter"></i></span></a></li><li><a href="https://www.linkedin.com/company/12181" title="LinkedIn"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-linkedin"></i></span></a></li><li><a href="http://stackoverflow.com/jobs/companies/opentable" title="StackOverflow"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-stack-overflow"></i></span></a></li></ul><p class="copyright text-muted">© OpenTable • 2017 • <a href="mailto:undefined"></a>
</p><p class="theme-by text-muted">Theme by
<a href="https://github.com/twoyao/beautiful-hexo">beautiful-hexo</a></p></div></div></div></footer><script src="/js/jquery-1.11.2.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="/js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
    a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-2621903-16', 'auto');
ga('send', 'pageview');</script></body></html>